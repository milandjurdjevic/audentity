# Audentity

**Auditing library for Entity Framework**

## Usage

Collect traces by catching the state of the `Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker`
before saving changes. That can be done simply by overriding the `SaveChanges()` & `SaveChangesAsync(CancellationToken)`
methods in your `Microsoft.EntityFrameworkCore.DbContext` implementation.

### Collecting Traces

```csharp
public class MyDbContext : DbContext
{
    public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = new())
    {
        EntityTrace[] traces = Collect.Traces(ChangeTracker.Entries()).ToArray();
        int result = await base.SaveChangesAsync(cancellationToken);
        // Process traces...
        return result;
    }
}
```

### Merging Owned Traces

Some traces can be owned by another trace
([see more](https://learn.microsoft.com/en-us/ef/core/modeling/owned-entities)). Trace collection can be transformed to
show owned trace properties inside the owner trace property collection.

```csharp
EntityTrace[] traces = Collect.Traces(ChangeTracker.Entries()).ToArray();
EntityTrace[] transformed = Merge.Traces(traces).ToArray();
```

### Shadow Entries

If you have many-to-many relationships in your database model, Entity Framework will generate a shadow entity that
represents a reference between two entities - unless you have defined such an entity yourself.

```csharp
public class Project
{
    public Guid Id { get; set; }
    public IEnumerable<User> Users { get; set; }
}

public class User
{
    public Guid Id { get; set; }
    public IEnumerable<Project> Projects { get; set; }
}

// Shadow entity generated by Entity Framework:
public class ProjectUser
{
    public Guid ProjectId { get; set; }
    public Guid UserId { get; set; }
}
```

Those entities, even if they are not defined in the code itself, will still end up in our trace collection.
To exclude them from traces, you can filter all entries by their CLR type before collecting traces.

```csharp
ChangeTracker
    .Entries()
    .Where(e => e.Type != typeof(Dictionary<string, object>))
    .Collect();
```
